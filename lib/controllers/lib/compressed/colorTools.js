var UTILS = { distance: function(color1, color2){ return Math.sqrt(Math.pow(color1.r - color2.r,2) + Math.pow(color1.g - color2.g,2) + Math.pow(color1.b - color2.b,2)); }, distanceMap: function(palette){ this.preparePalette(palette); var map = []; for (var i = 0, l = palette.length; i < l; i++) { map[i] = []; map[i][i] = [0, i]; } for (var i = 0, l = palette.length; i < l; i++) { for (var j = i + 1, l = palette.length; j < l; j++) { var d = this.distance(palette[i], palette[j]); map[i][j] = [d, j]; map[j][i] = [d, i]; } } return map; }, distanceSortedMap: function(palette){ this.preparePalette(palette); var map = this.distanceMap(palette); for (var i = 0, l = palette.length; i < l; i++) { map[i].sort(function(){ function(left, right) { return left[0] < right[0] ? -1 : 1; } }); } return map; }, preparePalette: function(palette){ if (!palette.sorted) { palette.sort(); palette.sorted = true; }; }, getPaletteIndex: function(color, palette){ this.preparePalette(palette); return palette.indexOf(color); }, ringAssignment: function(palette){ var map = distanceSortedMap(palette); var assignment = []; assignment[0] = 0; for (var i = 0, l = palette.length; i < l; i++) { var ring=[0, 1, 2, 3]; if (ring.indexOf(assignment[i])>= 0) { ring.splice(assignment[i], 1); } var j=h = k=0, mapi=map[i]; function assign(i, j, k, mapi){ var mapj=mapi[j], maph=mapi[h], mapk=mapi[k]; } while (ring.length > 0){ var mapj=mapi[j], maph=mapi[h], mapk=mapi[k]; if (mapj[0] === 0) { }; else if (maph[0] === 0) assign(j,k,k+1); else if (mapk[0] === 0) assign(j,h,k+1); else { var aj=assignment[ mapj[1] ], ah=assignment[ maph[1] ], ak=assignment[ mapk[1] ]; if (ring.indexOf(aj) > 0){ } } } } } }; module.exports = UTILS;